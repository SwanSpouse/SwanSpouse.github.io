---
title: linux io模型
date: 2018-09-09 15:54:28
tags:
  - linux
---

### Linux 网络I/O模型

Linux的内核将所有外部设备都看作一个文件来操作。对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor fd)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)。描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性）。

#### 阻塞I/O模型

缺省的情形下，所有文件操作都是阻塞的。以套接字接口为例，在进程中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型。

![BlockingIO](https://s1.ax1x.com/2018/09/09/iiQRhQ.png)

#### 非阻塞I/O模型

recvfrom 从应用层到内核的时候，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态。

![Non-blockingIO](https://s1.ax1x.com/2018/09/09/iiQ4cn.png)

阻塞与非阻塞模型的区别在于：非阻塞在发生系统调用的时候, 无论是否有数据都会立即返回。

正是由于每次系统会立即返回，所以想知道内核中数据是否准备好，就需要反复对内核进行轮询。但是在轮询之间，非阻塞模型可以做一些其他的操作，以提供CPU利用率。但同时也增加了此任务的响应延迟。因为每隔一段时间才去轮询，导致任务完成后不能得到及时的处理。

#### I/O复用模型

linux提供了select/poll，进程通过将一个或者多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback

![IOMultiplexing](https://s1.ax1x.com/2018/09/09/iiQfpj.png)

I/O复用模型和阻塞I/O相比，用户进程都是被block住了，但是I/O复用模型是block在了select操作；而阻塞I/O模型是block在了socket上。

在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。


#### 信号驱动I/O模型

首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。

![](https://s1.ax1x.com/2018/09/09/iiQ5Xq.png)

信号驱动性能要比select/poll高，但是缺点是致命的 —— Linux信号队列是有限制的，如果超过这个限制就完全无法读取数据。

#### 异步I/O模型

告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O模型由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。

![AsynchronousIO](https://s1.ax1x.com/2018/09/09/iiQh1s.png)

这种模型是最"省事"的模型，系统调用完成之后就只要坐等数据就可以了。其实不然，问题出在实际上，Linux上的AIO两个实现版本，POSIX的实现最烂，性能很差而且是基于"事件驱动"还会出现"信号队列不足"的问题（所以它就偷偷的创建线程，导致线程也不可控了）；一个是Linux自己实现的（readhat贡献）Native I/O。 Native I/O主要涉及到的两个函数 io_submit 设置需要I/O动作（读、写、数据大小、应用缓冲区）； io_getevents 等待I/O 动作完成。即便你的整个I/O行为是非阻塞的还是需要有一个办法知道数据是否读取、写入成功。

#### reference

* 《Netty 权威指南 第二版》
