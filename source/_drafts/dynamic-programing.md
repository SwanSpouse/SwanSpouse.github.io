---
title: 动态规划
date: 2018-10-11 22:17:25
tags:
  - algorithm
---

分治算法是指将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子问题。在这种情况下，若用分治算法则会做许多不必要的工作，即重复地求解公共的子子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。

动态规划通常应用于最优化问题。动态规划算法的设计可以分为如下四个步骤：
  1. 描述最优解的结构。
  2. 递归定义最优解的值。
  3. 按自底向上的方式计算最优解的值。
  4. 有计算出的结果构造一个最优解。 有时在第3步的计算中记录一些附加信息，可以第4步变得更加容易。

最优子结构可以用来判断是否可以用动态规划的方法来解决问题。

其实这个装配线的例题很好。很能说明上面这四个步骤。看看还有没有别的例题更加有说服力。

动态规划问题有个经典的文章叫做《背包九讲》，但是现在我已经找不到哪个是第一版本了。


#### 01背包

有N件物品和一个容量为V的背包，第i件物品的重量是w[i]，价值是v[i]，每件物品仅有一件，求解将哪些物品装入背包可使这些物品的总重量不超过背包容量，且价值总和最大。

f[i][v] = max{ f[i-1][v], f[i-1][v-w[i]]+v[i]}

#### 完全背包

有N种物品和一个容量为V的背包，第i种物品的费用是w[i]，价值是v[i]，每件物品有无数件，求解将哪些物品装入背包可使这些物品的总重量不超过背包容量，且价值总和最大。

f[i][v] = max{ f[i-1][v - k*c[i]]+ k*w[i] | 0<= k*c[i] <= v} 其中k为每件物品放入背包的件数。

完全背包问题可以转化为01背包问题。把第i种物品拆成价值为v[i] * 2^k、重量为w[i] * 2^k的若干件物品，其中k满足w[i] * 2^k <V。

#### 多重背包问题

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的总重量不超过背包容量，且价值总和最大。

同样，多重背包问题可以转化为01背包问题。

#### 混合背包
#### 二维费用的背包问题
#### 分组的背包问题
#### 有依赖的背包问题
#### 泛化物品
#### 背包问题问法的变化

f[i][v] = max{ f[i-1][v - k*c[i]]+ k*w[i] | 0<= k*c[i] <= v, k <= n[i]} 其中k为每件物品放入背包的件数。

### 120. Triangle

[120. Triangle](https://leetcode.com/problems/triangle/description/)

设状态为dp(i,j),表示从位置(i,j)出发，路径的最小和，则状态转移方程为:

dp(i, j) = min{ dp(i, j + 1), dp(i + 1, j + 1)} + (i, j)

### 53. Maximum Subarray

[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

dp[j] = max{dp[j-1] + S[j], S[j]}, 1 <= j <= n

target = max{dp[j]}


### 152. Maximum Product Subarray

[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/description/)

和上一题相比，除了需要记录当前的最大值之外，还需要对当前的最小值进行记录。

maxArr[j] = max{maxArr[j-1] * S[j], S[j], minArr[j-1] * S[j] }
minArr[j] = min{minArr[j-1] * S[j], S[j], maxArr[j-1] * S[j] }



### reference
* https://leetcode.com/
