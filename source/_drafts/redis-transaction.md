---
title: Redis事务
tags:
    - redis
---

#### redis操作原子性

Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的。它采用IO多路复用技术来保证在多连接的时候系统的高吞吐量。所以Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。

#### redis批量操作原子性（事务）

MULTI、EXEC、DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令，并且带有以下两个重要的保证：

* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

Redis 在事务失败时不进行回滚，而是继续执行余下的命令

* Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。

* 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。有种观点认为 Redis 处理事务的做法会产生 bug，然而需要注意的是，在通常情况下，回滚并不能解决编程错误带来的问题。举个例子， 如果你本来想通过 INCR 命令将键的值加上1 ，却不小心加上了2，又或者对错误类型的键执行了INCR， 回滚是没有办法处理这些情况的。

#### Lua脚本实现原子性

Redis 服务器会单线程原子性执行lua 脚本，保证lua 脚本在处理的过程中不会被任意其它请求打断。

例如，它可以将匹配 key 和删除 key 合并在一起原子性执行，Redis 原生没有提供这样功能的指令，它可以使用 lua 脚本来完成。

```shell
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
